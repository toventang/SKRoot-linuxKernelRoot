#pragma once
#include <string.h>
#include <unistd.h>
#include "module_base_err_def.h"

namespace kernel_module {
struct caps_info {
    uint64_t inheritable = 0;
    uint64_t permitted = 0;
    uint64_t effective = 0;
    uint64_t bounding = 0;
    uint64_t ambient = 0;
};

/***************************************************************************
 * 获取 cred 结构体中 uid 字段的偏移量
 * 参数: root_key           ROOT权限密钥文本
 *       cred_uid_offset  输出参数，返回 uid 字段相对于 cred 起始的偏移量（字节）
 * 返回: OK 表示成功；其它值为错误码
 ***************************************************************************/
KModErr get_cred_uid_offset(const char* root_key, uint32_t& cred_uid_offset);

/***************************************************************************
 * 获取当前内核支持的能力集字段数量
 * 返回: 能力集字段数
 ***************************************************************************/
int get_caps_cnt();

/***************************************************************************
 * 获取当前内核支持的最大能力位 (CAP_LAST_CAP)
 * 返回: 能力位掩码 (每一位表示一个 CAP)
 ***************************************************************************/
uint64_t get_cap_ability_max();

/***************************************************************************
 * 获取当前进程能力集
 * 参数: out 输出能力集
 * 返回: OK 表示成功；其它值为错误码
 ***************************************************************************/
KModErr get_current_caps(caps_info& out);

/***************************************************************************
 * 设置当前进程能力集
 * 参数: root_key       ROOT权限密钥文本
 *       new_caps       新的能力集
 * 返回: OK 表示成功；其它值为错误码
 ***************************************************************************/
KModErr set_current_caps(const char* root_key, const caps_info& new_caps);

}
